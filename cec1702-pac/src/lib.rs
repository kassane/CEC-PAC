#![doc = "Peripheral access API for CEC1702 microcontrollers (generated using svd2rust v0.25.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.25.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn GIRQ08();
    fn GIRQ09();
    fn GIRQ10();
    fn GIRQ11();
    fn GIRQ12();
    fn GIRQ26();
    fn SMB0();
    fn SMB1();
    fn SMB2();
    fn SMB3();
    fn DMA_CH00();
    fn DMA_CH01();
    fn DMA_CH02();
    fn DMA_CH03();
    fn DMA_CH04();
    fn DMA_CH05();
    fn DMA_CH06();
    fn DMA_CH07();
    fn DMA_CH08();
    fn DMA_CH09();
    fn DMA_CH10();
    fn DMA_CH11();
    fn DMA_CH12();
    fn DMA_CH13();
    fn UART0();
    fn UART1();
    fn TACH0();
    fn TACH1();
    fn RPM2PWM_0_FAIL();
    fn RPM2PWM_0_STALL();
    fn RPM2PWM_1_FAIL();
    fn RPM2PWM_1_STALL();
    fn SNGL();
    fn RPT();
    fn RC_ID0();
    fn RC_ID1();
    fn LED0();
    fn LED1();
    fn QMSPI();
    fn TX0();
    fn RX0();
    fn TIMER();
    fn HTM0();
    fn HTM1();
    fn ALARM_INT();
    fn WKSUB();
    fn WKSEC();
    fn WKSUBSEC();
    fn SYSPWR();
    fn RTC();
    fn RTC_ALARM();
    fn OVRD_IN();
    fn IN0();
    fn IN1();
    fn IN2();
    fn IN3();
    fn IN4();
    fn IN5();
    fn IN6();
    fn KMS();
    fn TIMER16_0();
    fn TIMER16_1();
    fn TIMER16_2();
    fn TIMER16_3();
    fn TIMER32_0();
    fn TIMER32_1();
    fn CNT_TMR0();
    fn CNT_TMR1();
    fn CNT_TMR2();
    fn CNT_TMR3();
    fn CAPTURE_TIMER();
    fn CAPTURE_0();
    fn CAPTURE_1();
    fn CAPTURE_2();
    fn CAPTURE_3();
    fn CAPTURE_4();
    fn CAPTURE_5();
    fn COMPARE_0();
    fn COMPARE_1();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 155] = [
    Vector { _handler: GIRQ08 },
    Vector { _handler: GIRQ09 },
    Vector { _handler: GIRQ10 },
    Vector { _handler: GIRQ11 },
    Vector { _handler: GIRQ12 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ26 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SMB0 },
    Vector { _handler: SMB1 },
    Vector { _handler: SMB2 },
    Vector { _handler: SMB3 },
    Vector { _handler: DMA_CH00 },
    Vector { _handler: DMA_CH01 },
    Vector { _handler: DMA_CH02 },
    Vector { _handler: DMA_CH03 },
    Vector { _handler: DMA_CH04 },
    Vector { _handler: DMA_CH05 },
    Vector { _handler: DMA_CH06 },
    Vector { _handler: DMA_CH07 },
    Vector { _handler: DMA_CH08 },
    Vector { _handler: DMA_CH09 },
    Vector { _handler: DMA_CH10 },
    Vector { _handler: DMA_CH11 },
    Vector { _handler: DMA_CH12 },
    Vector { _handler: DMA_CH13 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TACH0 },
    Vector { _handler: TACH1 },
    Vector { _reserved: 0 },
    Vector {
        _handler: RPM2PWM_0_FAIL,
    },
    Vector {
        _handler: RPM2PWM_0_STALL,
    },
    Vector {
        _handler: RPM2PWM_1_FAIL,
    },
    Vector {
        _handler: RPM2PWM_1_STALL,
    },
    Vector { _handler: SNGL },
    Vector { _handler: RPT },
    Vector { _handler: RC_ID0 },
    Vector { _handler: RC_ID1 },
    Vector { _reserved: 0 },
    Vector { _handler: LED0 },
    Vector { _handler: LED1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: QMSPI },
    Vector { _handler: TX0 },
    Vector { _handler: RX0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TIMER },
    Vector { _handler: HTM0 },
    Vector { _handler: HTM1 },
    Vector {
        _handler: ALARM_INT,
    },
    Vector { _handler: WKSUB },
    Vector { _handler: WKSEC },
    Vector { _handler: WKSUBSEC },
    Vector { _handler: SYSPWR },
    Vector { _handler: RTC },
    Vector {
        _handler: RTC_ALARM,
    },
    Vector { _handler: OVRD_IN },
    Vector { _handler: IN0 },
    Vector { _handler: IN1 },
    Vector { _handler: IN2 },
    Vector { _handler: IN3 },
    Vector { _handler: IN4 },
    Vector { _handler: IN5 },
    Vector { _handler: IN6 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: KMS },
    Vector {
        _handler: TIMER16_0,
    },
    Vector {
        _handler: TIMER16_1,
    },
    Vector {
        _handler: TIMER16_2,
    },
    Vector {
        _handler: TIMER16_3,
    },
    Vector {
        _handler: TIMER32_0,
    },
    Vector {
        _handler: TIMER32_1,
    },
    Vector { _handler: CNT_TMR0 },
    Vector { _handler: CNT_TMR1 },
    Vector { _handler: CNT_TMR2 },
    Vector { _handler: CNT_TMR3 },
    Vector {
        _handler: CAPTURE_TIMER,
    },
    Vector {
        _handler: CAPTURE_0,
    },
    Vector {
        _handler: CAPTURE_1,
    },
    Vector {
        _handler: CAPTURE_2,
    },
    Vector {
        _handler: CAPTURE_3,
    },
    Vector {
        _handler: CAPTURE_4,
    },
    Vector {
        _handler: CAPTURE_5,
    },
    Vector {
        _handler: COMPARE_0,
    },
    Vector {
        _handler: COMPARE_1,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - SMB0"]
    SMB0 = 20,
    #[doc = "21 - SMB1"]
    SMB1 = 21,
    #[doc = "22 - SMB2"]
    SMB2 = 22,
    #[doc = "23 - SMB3"]
    SMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "34 - DMA_CH10"]
    DMA_CH10 = 34,
    #[doc = "35 - DMA_CH11"]
    DMA_CH11 = 35,
    #[doc = "36 - DMA_CH12"]
    DMA_CH12 = 36,
    #[doc = "37 - DMA_CH13"]
    DMA_CH13 = 37,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "41 - UART1"]
    UART1 = 41,
    #[doc = "71 - TACH0"]
    TACH0 = 71,
    #[doc = "72 - TACH1"]
    TACH1 = 72,
    #[doc = "74 - RPM2PWM_0_FAIL"]
    RPM2PWM_0_FAIL = 74,
    #[doc = "75 - RPM2PWM_0_STALL"]
    RPM2PWM_0_STALL = 75,
    #[doc = "76 - RPM2PWM_1_FAIL"]
    RPM2PWM_1_FAIL = 76,
    #[doc = "77 - RPM2PWM_1_STALL"]
    RPM2PWM_1_STALL = 77,
    #[doc = "78 - SNGL"]
    SNGL = 78,
    #[doc = "79 - RPT"]
    RPT = 79,
    #[doc = "80 - RC_ID0"]
    RC_ID0 = 80,
    #[doc = "81 - RC_ID1"]
    RC_ID1 = 81,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "91 - QMSPI"]
    QMSPI = 91,
    #[doc = "92 - TX0"]
    TX0 = 92,
    #[doc = "93 - RX0"]
    RX0 = 93,
    #[doc = "111 - TIMER"]
    TIMER = 111,
    #[doc = "112 - HTM0"]
    HTM0 = 112,
    #[doc = "113 - HTM1"]
    HTM1 = 113,
    #[doc = "114 - ALARM_INT"]
    ALARM_INT = 114,
    #[doc = "115 - WKSUB"]
    WKSUB = 115,
    #[doc = "116 - WKSEC"]
    WKSEC = 116,
    #[doc = "117 - WKSUBSEC"]
    WKSUBSEC = 117,
    #[doc = "118 - SYSPWR"]
    SYSPWR = 118,
    #[doc = "119 - RTC"]
    RTC = 119,
    #[doc = "120 - RTC_ALARM"]
    RTC_ALARM = 120,
    #[doc = "121 - OVRD_IN"]
    OVRD_IN = 121,
    #[doc = "122 - IN0"]
    IN0 = 122,
    #[doc = "123 - IN1"]
    IN1 = 123,
    #[doc = "124 - IN2"]
    IN2 = 124,
    #[doc = "125 - IN3"]
    IN3 = 125,
    #[doc = "126 - IN4"]
    IN4 = 126,
    #[doc = "127 - IN5"]
    IN5 = 127,
    #[doc = "128 - IN6"]
    IN6 = 128,
    #[doc = "135 - KMS"]
    KMS = 135,
    #[doc = "136 - TIMER16_0"]
    TIMER16_0 = 136,
    #[doc = "137 - TIMER16_1"]
    TIMER16_1 = 137,
    #[doc = "138 - TIMER16_2"]
    TIMER16_2 = 138,
    #[doc = "139 - TIMER16_3"]
    TIMER16_3 = 139,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "142 - CNT_TMR0"]
    CNT_TMR0 = 142,
    #[doc = "143 - CNT_TMR1"]
    CNT_TMR1 = 143,
    #[doc = "144 - CNT_TMR2"]
    CNT_TMR2 = 144,
    #[doc = "145 - CNT_TMR3"]
    CNT_TMR3 = 145,
    #[doc = "146 - CAPTURE_TIMER"]
    CAPTURE_TIMER = 146,
    #[doc = "147 - CAPTURE_0"]
    CAPTURE_0 = 147,
    #[doc = "148 - CAPTURE_1"]
    CAPTURE_1 = 148,
    #[doc = "149 - CAPTURE_2"]
    CAPTURE_2 = 149,
    #[doc = "150 - CAPTURE_3"]
    CAPTURE_3 = 150,
    #[doc = "151 - CAPTURE_4"]
    CAPTURE_4 = 151,
    #[doc = "152 - CAPTURE_5"]
    CAPTURE_5 = 152,
    #[doc = "153 - COMPARE_0"]
    COMPARE_0 = 153,
    #[doc = "154 - COMPARE_1"]
    COMPARE_1 = 154,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies all the power supplies,\n clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals."]
pub struct PCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PCR {}
impl PCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcr::RegisterBlock = 0x4008_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PCR {
    type Target = pcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PCR").finish()
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies all the power supplies,\n clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals."]
pub mod pcr;
#[doc = "DMA Main Registers"]
pub struct DMA_MAIN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_MAIN {}
impl DMA_MAIN {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_main::RegisterBlock = 0x4000_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_main::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_MAIN {
    type Target = dma_main::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_MAIN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_MAIN").finish()
    }
}
#[doc = "DMA Main Registers"]
pub mod dma_main;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN00 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN00 {}
impl DMA_CHAN00 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan00::RegisterBlock = 0x4000_2440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan00::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN00 {
    type Target = dma_chan00::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN00 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN00").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub mod dma_chan00;
#[doc = "DMA Channel 01 Registers"]
pub struct DMA_CHAN01 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN01 {}
impl DMA_CHAN01 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan01::RegisterBlock = 0x4000_2480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan01::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN01 {
    type Target = dma_chan01::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN01").finish()
    }
}
#[doc = "DMA Channel 01 Registers"]
pub mod dma_chan01;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN02 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN02 {}
impl DMA_CHAN02 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_24c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN02 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN02 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN02").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub mod dma_chan02;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN03 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN03 {}
impl DMA_CHAN03 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN03 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN03").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan03;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN04 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN04 {}
impl DMA_CHAN04 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN04 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN04 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN04").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan04;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN05 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN05 {}
impl DMA_CHAN05 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN05 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN05 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN05").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan05;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN06 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN06 {}
impl DMA_CHAN06 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_25c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN06 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN06 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN06").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan06;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN07 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN07 {}
impl DMA_CHAN07 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN07 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN07 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN07").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan07;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN08 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN08 {}
impl DMA_CHAN08 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN08 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN08 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN08").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan08;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN09 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN09 {}
impl DMA_CHAN09 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN09 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN09 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN09").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan09;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN10 {}
impl DMA_CHAN10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_26c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN10 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN10").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan10;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN11 {}
impl DMA_CHAN11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN11 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN11").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan11;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN12 {}
impl DMA_CHAN12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2740 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN12 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN12").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan12;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN13 {}
impl DMA_CHAN13 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2780 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN13 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN13").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub use dma_chan02 as dma_chan13;
#[doc = "The interrupt generation logic is made of 16 groups of signals, each of which\n consist of a Status register, a Enable register and a Result register. The Status and Enable are\n latched registers. The Result register is a bit by bit AND function of the Source and Enable registers.\n All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block\n Select register to form the interrupt signal that is routed to the ARM interrupt controller."]
pub struct ECIA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ECIA {}
impl ECIA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecia::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecia::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ECIA {
    type Target = ecia::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ECIA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ECIA").finish()
    }
}
#[doc = "The interrupt generation logic is made of 16 groups of signals, each of which\n consist of a Status register, a Enable register and a Result register. The Status and Enable are\n latched registers. The Result register is a bit by bit AND function of the Source and Enable registers.\n All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block\n Select register to form the interrupt signal that is routed to the ARM interrupt controller."]
pub mod ecia;
#[doc = "The Logical Device Configuration registers support motherboard designs in\n which the resources required by their components are known and assigned by the BIOS\n at POST."]
pub struct GCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GCR {}
impl GCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gcr::RegisterBlock = 0x400f_ff00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GCR {
    type Target = gcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GCR").finish()
    }
}
#[doc = "The Logical Device Configuration registers support motherboard designs in\n which the resources required by their components are known and assigned by the BIOS\n at POST."]
pub mod gcr;
#[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x400f_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub mod uart0;
#[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x400f_2800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub use uart0 as uart1;
#[doc = "GPIO Pin Control Registers"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO Pin Control Registers"]
pub mod gpio;
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect\n if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit\n will generate a WDT Event if the user program fails to reload the WDT within a specified length\n of time known as the WDT Interval."]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect\n if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit\n will generate a WDT Event if the user program fails to reload the WDT within a specified length\n of time known as the WDT Interval."]
pub mod wdt;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub struct TIMER16_0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_0 {}
impl TIMER16_0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_0 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_0").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub mod timer16_0;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub struct TIMER16_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_1 {}
impl TIMER16_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c20 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_1 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_1").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub use timer16_0 as timer16_1;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub struct TIMER16_2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_2 {}
impl TIMER16_2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c40 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_2 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_2").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub use timer16_0 as timer16_2;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub struct TIMER16_3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_3 {}
impl TIMER16_3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_3 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_3").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n The name of the timer instance indicates the size of the timer."]
pub use timer16_0 as timer16_3;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as \n 32 bits. The name of the timer instance indicates the size of the timer."]
pub struct TIMER32_0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_0 {}
impl TIMER32_0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_0 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_0").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as \n 32 bits. The name of the timer instance indicates the size of the timer."]
pub mod timer32_0;
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as \n 32 bits. The name of the timer instance indicates the size of the timer."]
pub struct TIMER32_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_1 {}
impl TIMER32_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0ca0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_1 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_1").finish()
    }
}
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as \n 32 bits. The name of the timer instance indicates the size of the timer."]
pub use timer32_0 as timer32_1;
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub struct CNT_TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CNT_TMR0 {}
impl CNT_TMR0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cnt_tmr0::RegisterBlock = 0x4000_0d00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cnt_tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CNT_TMR0 {
    type Target = cnt_tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CNT_TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CNT_TMR0").finish()
    }
}
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub mod cnt_tmr0;
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub struct CNT_TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CNT_TMR1 {}
impl CNT_TMR1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cnt_tmr0::RegisterBlock = 0x4000_0d20 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cnt_tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CNT_TMR1 {
    type Target = cnt_tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CNT_TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CNT_TMR1").finish()
    }
}
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub use cnt_tmr0 as cnt_tmr1;
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub struct CNT_TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CNT_TMR2 {}
impl CNT_TMR2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cnt_tmr0::RegisterBlock = 0x4000_0d40 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cnt_tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CNT_TMR2 {
    type Target = cnt_tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CNT_TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CNT_TMR2").finish()
    }
}
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub use cnt_tmr0 as cnt_tmr2;
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub struct CNT_TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CNT_TMR3 {}
impl CNT_TMR3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cnt_tmr0::RegisterBlock = 0x4000_0d60 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cnt_tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CNT_TMR3 {
    type Target = cnt_tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CNT_TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CNT_TMR3").finish()
    }
}
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub use cnt_tmr0 as cnt_tmr3;
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub struct CCT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CCT {}
impl CCT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cct::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cct::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CCT {
    type Target = cct::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CCT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CCT").finish()
    }
}
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub mod cct;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.\n This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed\n in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
pub struct HTM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM0 {}
impl HTM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM0 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM0").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.\n This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed\n in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
pub mod htm0;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.\n This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed\n in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
pub struct HTM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM1 {}
impl HTM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM1 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM1").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.\n This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed\n in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
pub use htm0 as htm1;
#[doc = "The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all\n chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and\n wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the\n timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be\n halted during debug by hardware or via a software control bit."]
pub struct RTOS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTOS {}
impl RTOS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtos::RegisterBlock = 0x4000_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtos::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTOS {
    type Target = rtos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTOS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTOS").finish()
    }
}
#[doc = "The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all\n chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and\n wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the\n timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be\n halted during debug by hardware or via a software control bit."]
pub mod rtos;
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled\n to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year."]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x400f_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled\n to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year."]
pub mod rtc;
#[doc = "The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer\n and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state."]
pub struct WEEK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WEEK {}
impl WEEK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const week::RegisterBlock = 0x4000_ac80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const week::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WEEK {
    type Target = week::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WEEK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WEEK").finish()
    }
}
#[doc = "The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer\n and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state."]
pub mod week;
#[doc = "This block monitors TACH output signals (or locked rotor signals) from\n various types of fans, and determines their speed."]
pub struct TACH0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TACH0 {}
impl TACH0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tach0::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tach0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TACH0 {
    type Target = tach0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TACH0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TACH0").finish()
    }
}
#[doc = "This block monitors TACH output signals (or locked rotor signals) from\n various types of fans, and determines their speed."]
pub mod tach0;
#[doc = "This block monitors TACH output signals (or locked rotor signals) from\n various types of fans, and determines their speed."]
pub struct TACH1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TACH1 {}
impl TACH1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tach0::RegisterBlock = 0x4000_6010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tach0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TACH1 {
    type Target = tach0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TACH1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TACH1").finish()
    }
}
#[doc = "This block monitors TACH output signals (or locked rotor signals) from\n various types of fans, and determines their speed."]
pub use tach0 as tach1;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM0 {}
impl PWM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM0").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub mod pwm0;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM1 {}
impl PWM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5810 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM1 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM1").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm1;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM2 {}
impl PWM2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM2 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM2").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm2;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM3 {}
impl PWM3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5830 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM3 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM3").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm3;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM4 {}
impl PWM4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5840 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM4 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM4").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm4;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM5 {}
impl PWM5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5850 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM5 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM5").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm5;
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub struct PWM10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM10 {}
impl PWM10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_58a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM10 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM10").finish()
    }
}
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub use pwm0 as pwm10;
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4000_7c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub mod adc;
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts\n the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub struct FAN0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FAN0 {}
impl FAN0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fan0::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fan0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FAN0 {
    type Target = fan0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FAN0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FAN0").finish()
    }
}
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts\n the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub mod fan0;
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts\n the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub struct FAN1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FAN1 {}
impl FAN1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fan0::RegisterBlock = 0x4000_a080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fan0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FAN1 {
    type Target = fan0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FAN1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FAN1").finish()
    }
}
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts\n the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub use fan0 as fan1;
#[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz\n clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit\n PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
pub struct LED0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED0 {}
impl LED0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED0 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED0").finish()
    }
}
#[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz\n clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit\n PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
pub mod led0;
#[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz\n clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit\n PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
pub struct LED1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED1 {}
impl LED1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED1 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED1").finish()
    }
}
#[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz\n clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit\n PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
pub use led0 as led1;
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub struct RC_ID0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RC_ID0 {}
impl RC_ID0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rc_id0::RegisterBlock = 0x4000_1400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rc_id0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RC_ID0 {
    type Target = rc_id0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RC_ID0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RC_ID0").finish()
    }
}
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub mod rc_id0;
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub struct RC_ID1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RC_ID1 {}
impl RC_ID1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rc_id0::RegisterBlock = 0x4000_1480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rc_id0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RC_ID1 {
    type Target = rc_id0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RC_ID1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RC_ID1").finish()
    }
}
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub use rc_id0 as rc_id1;
#[doc = "The Keyboard Scan Interface block provides a register interface to the EC\n to directly scan an external keyboard matrix of size up to 18x8."]
pub struct KMS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KMS {}
impl KMS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const kms::RegisterBlock = 0x4000_9c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kms::RegisterBlock {
        Self::PTR
    }
}
impl Deref for KMS {
    type Target = kms::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for KMS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KMS").finish()
    }
}
#[doc = "The Keyboard Scan Interface block provides a register interface to the EC\n to directly scan an external keyboard matrix of size up to 18x8."]
pub mod kms;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB0 {}
impl SMB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB0 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB0").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub mod smb0;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB1 {}
impl SMB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB1 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB1").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb1;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB2 {}
impl SMB2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB2 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB2").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb2;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB3 {}
impl SMB3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB3 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB3").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb3;
#[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used\n to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a\n standard Serial Peripheral Interface."]
pub struct GP_SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GP_SPI0 {}
impl GP_SPI0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gp_spi0::RegisterBlock = 0x4000_9400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gp_spi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GP_SPI0 {
    type Target = gp_spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GP_SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GP_SPI0").finish()
    }
}
#[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used\n to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a\n standard Serial Peripheral Interface."]
pub mod gp_spi0;
#[doc = "The Quad SPI Master Controller may be used to communicate with various \n peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols."]
pub struct QMSPI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QMSPI {}
impl QMSPI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qmspi::RegisterBlock = 0x4000_5400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qmspi::RegisterBlock {
        Self::PTR
    }
}
impl Deref for QMSPI {
    type Target = qmspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QMSPI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QMSPI").finish()
    }
}
#[doc = "The Quad SPI Master Controller may be used to communicate with various \n peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols."]
pub mod qmspi;
#[doc = "The TFDP serially transmits Embedded Controller (EC)-originated \n diagnostic vectors to an external debug trace system."]
pub struct TFDP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TFDP {}
impl TFDP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tfdp::RegisterBlock = 0x4000_8c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tfdp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TFDP {
    type Target = tfdp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TFDP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TFDP").finish()
    }
}
#[doc = "The TFDP serially transmits Embedded Controller (EC)-originated \n diagnostic vectors to an external debug trace system."]
pub mod tfdp;
#[doc = "The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins.\n The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub struct VCI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VCI {}
impl VCI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vci::RegisterBlock = 0x4000_ae00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vci::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VCI {
    type Target = vci::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VCI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VCI").finish()
    }
}
#[doc = "The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins.\n The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub mod vci;
#[doc = "The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main \n power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub struct VBAT_RAM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VBAT_RAM {}
impl VBAT_RAM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vbat_ram::RegisterBlock = 0x4000_a800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vbat_ram::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VBAT_RAM {
    type Target = vbat_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VBAT_RAM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VBAT_RAM").finish()
    }
}
#[doc = "The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main \n power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub mod vbat_ram;
#[doc = "The VBAT Register Bank block is a block implemented for aggregating miscellaneous\n battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are\n not unique to a block implemented in the EC subsystem."]
pub struct VBAT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VBAT {}
impl VBAT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vbat::RegisterBlock = 0x4000_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vbat::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VBAT {
    type Target = vbat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VBAT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VBAT").finish()
    }
}
#[doc = "The VBAT Register Bank block is a block implemented for aggregating miscellaneous\n battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are\n not unique to a block implemented in the EC subsystem."]
pub mod vbat;
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub struct EC_REG_BANK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EC_REG_BANK {}
impl EC_REG_BANK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ec_reg_bank::RegisterBlock = 0x4000_fc04 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ec_reg_bank::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EC_REG_BANK {
    type Target = ec_reg_bank::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EC_REG_BANK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EC_REG_BANK").finish()
    }
}
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub mod ec_reg_bank;
#[doc = "The eFUSE block provides a means of programming and accessing the eFUSE bits."]
pub struct EFUSE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EFUSE {}
impl EFUSE {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const efuse::RegisterBlock = 0x4008_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const efuse::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EFUSE {
    type Target = efuse::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EFUSE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EFUSE").finish()
    }
}
#[doc = "The eFUSE block provides a means of programming and accessing the eFUSE bits."]
pub mod efuse;
#[doc = "System timer"]
pub struct SYS_TICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS_TICK {}
impl SYS_TICK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sys_tick::RegisterBlock = 0xe000_e010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sys_tick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS_TICK {
    type Target = sys_tick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS_TICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS_TICK").finish()
    }
}
#[doc = "System timer"]
pub mod sys_tick;
#[doc = "System Control Registers"]
pub struct SYSTEM_CONTROL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTEM_CONTROL {}
impl SYSTEM_CONTROL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const system_control::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const system_control::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTEM_CONTROL {
    type Target = system_control::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTEM_CONTROL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTEM_CONTROL").finish()
    }
}
#[doc = "System Control Registers"]
pub mod system_control;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PCR"]
    pub PCR: PCR,
    #[doc = "DMA_MAIN"]
    pub DMA_MAIN: DMA_MAIN,
    #[doc = "DMA_CHAN00"]
    pub DMA_CHAN00: DMA_CHAN00,
    #[doc = "DMA_CHAN01"]
    pub DMA_CHAN01: DMA_CHAN01,
    #[doc = "DMA_CHAN02"]
    pub DMA_CHAN02: DMA_CHAN02,
    #[doc = "DMA_CHAN03"]
    pub DMA_CHAN03: DMA_CHAN03,
    #[doc = "DMA_CHAN04"]
    pub DMA_CHAN04: DMA_CHAN04,
    #[doc = "DMA_CHAN05"]
    pub DMA_CHAN05: DMA_CHAN05,
    #[doc = "DMA_CHAN06"]
    pub DMA_CHAN06: DMA_CHAN06,
    #[doc = "DMA_CHAN07"]
    pub DMA_CHAN07: DMA_CHAN07,
    #[doc = "DMA_CHAN08"]
    pub DMA_CHAN08: DMA_CHAN08,
    #[doc = "DMA_CHAN09"]
    pub DMA_CHAN09: DMA_CHAN09,
    #[doc = "DMA_CHAN10"]
    pub DMA_CHAN10: DMA_CHAN10,
    #[doc = "DMA_CHAN11"]
    pub DMA_CHAN11: DMA_CHAN11,
    #[doc = "DMA_CHAN12"]
    pub DMA_CHAN12: DMA_CHAN12,
    #[doc = "DMA_CHAN13"]
    pub DMA_CHAN13: DMA_CHAN13,
    #[doc = "ECIA"]
    pub ECIA: ECIA,
    #[doc = "GCR"]
    pub GCR: GCR,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "TIMER16_0"]
    pub TIMER16_0: TIMER16_0,
    #[doc = "TIMER16_1"]
    pub TIMER16_1: TIMER16_1,
    #[doc = "TIMER16_2"]
    pub TIMER16_2: TIMER16_2,
    #[doc = "TIMER16_3"]
    pub TIMER16_3: TIMER16_3,
    #[doc = "TIMER32_0"]
    pub TIMER32_0: TIMER32_0,
    #[doc = "TIMER32_1"]
    pub TIMER32_1: TIMER32_1,
    #[doc = "CNT_TMR0"]
    pub CNT_TMR0: CNT_TMR0,
    #[doc = "CNT_TMR1"]
    pub CNT_TMR1: CNT_TMR1,
    #[doc = "CNT_TMR2"]
    pub CNT_TMR2: CNT_TMR2,
    #[doc = "CNT_TMR3"]
    pub CNT_TMR3: CNT_TMR3,
    #[doc = "CCT"]
    pub CCT: CCT,
    #[doc = "HTM0"]
    pub HTM0: HTM0,
    #[doc = "HTM1"]
    pub HTM1: HTM1,
    #[doc = "RTOS"]
    pub RTOS: RTOS,
    #[doc = "RTC"]
    pub RTC: RTC,
    #[doc = "WEEK"]
    pub WEEK: WEEK,
    #[doc = "TACH0"]
    pub TACH0: TACH0,
    #[doc = "TACH1"]
    pub TACH1: TACH1,
    #[doc = "PWM0"]
    pub PWM0: PWM0,
    #[doc = "PWM1"]
    pub PWM1: PWM1,
    #[doc = "PWM2"]
    pub PWM2: PWM2,
    #[doc = "PWM3"]
    pub PWM3: PWM3,
    #[doc = "PWM4"]
    pub PWM4: PWM4,
    #[doc = "PWM5"]
    pub PWM5: PWM5,
    #[doc = "PWM10"]
    pub PWM10: PWM10,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "FAN0"]
    pub FAN0: FAN0,
    #[doc = "FAN1"]
    pub FAN1: FAN1,
    #[doc = "LED0"]
    pub LED0: LED0,
    #[doc = "LED1"]
    pub LED1: LED1,
    #[doc = "RC_ID0"]
    pub RC_ID0: RC_ID0,
    #[doc = "RC_ID1"]
    pub RC_ID1: RC_ID1,
    #[doc = "KMS"]
    pub KMS: KMS,
    #[doc = "SMB0"]
    pub SMB0: SMB0,
    #[doc = "SMB1"]
    pub SMB1: SMB1,
    #[doc = "SMB2"]
    pub SMB2: SMB2,
    #[doc = "SMB3"]
    pub SMB3: SMB3,
    #[doc = "GP_SPI0"]
    pub GP_SPI0: GP_SPI0,
    #[doc = "QMSPI"]
    pub QMSPI: QMSPI,
    #[doc = "TFDP"]
    pub TFDP: TFDP,
    #[doc = "VCI"]
    pub VCI: VCI,
    #[doc = "VBAT_RAM"]
    pub VBAT_RAM: VBAT_RAM,
    #[doc = "VBAT"]
    pub VBAT: VBAT,
    #[doc = "EC_REG_BANK"]
    pub EC_REG_BANK: EC_REG_BANK,
    #[doc = "EFUSE"]
    pub EFUSE: EFUSE,
    #[doc = "SYS_TICK"]
    pub SYS_TICK: SYS_TICK,
    #[doc = "SYSTEM_CONTROL"]
    pub SYSTEM_CONTROL: SYSTEM_CONTROL,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PCR: PCR {
                _marker: PhantomData,
            },
            DMA_MAIN: DMA_MAIN {
                _marker: PhantomData,
            },
            DMA_CHAN00: DMA_CHAN00 {
                _marker: PhantomData,
            },
            DMA_CHAN01: DMA_CHAN01 {
                _marker: PhantomData,
            },
            DMA_CHAN02: DMA_CHAN02 {
                _marker: PhantomData,
            },
            DMA_CHAN03: DMA_CHAN03 {
                _marker: PhantomData,
            },
            DMA_CHAN04: DMA_CHAN04 {
                _marker: PhantomData,
            },
            DMA_CHAN05: DMA_CHAN05 {
                _marker: PhantomData,
            },
            DMA_CHAN06: DMA_CHAN06 {
                _marker: PhantomData,
            },
            DMA_CHAN07: DMA_CHAN07 {
                _marker: PhantomData,
            },
            DMA_CHAN08: DMA_CHAN08 {
                _marker: PhantomData,
            },
            DMA_CHAN09: DMA_CHAN09 {
                _marker: PhantomData,
            },
            DMA_CHAN10: DMA_CHAN10 {
                _marker: PhantomData,
            },
            DMA_CHAN11: DMA_CHAN11 {
                _marker: PhantomData,
            },
            DMA_CHAN12: DMA_CHAN12 {
                _marker: PhantomData,
            },
            DMA_CHAN13: DMA_CHAN13 {
                _marker: PhantomData,
            },
            ECIA: ECIA {
                _marker: PhantomData,
            },
            GCR: GCR {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            WDT: WDT {
                _marker: PhantomData,
            },
            TIMER16_0: TIMER16_0 {
                _marker: PhantomData,
            },
            TIMER16_1: TIMER16_1 {
                _marker: PhantomData,
            },
            TIMER16_2: TIMER16_2 {
                _marker: PhantomData,
            },
            TIMER16_3: TIMER16_3 {
                _marker: PhantomData,
            },
            TIMER32_0: TIMER32_0 {
                _marker: PhantomData,
            },
            TIMER32_1: TIMER32_1 {
                _marker: PhantomData,
            },
            CNT_TMR0: CNT_TMR0 {
                _marker: PhantomData,
            },
            CNT_TMR1: CNT_TMR1 {
                _marker: PhantomData,
            },
            CNT_TMR2: CNT_TMR2 {
                _marker: PhantomData,
            },
            CNT_TMR3: CNT_TMR3 {
                _marker: PhantomData,
            },
            CCT: CCT {
                _marker: PhantomData,
            },
            HTM0: HTM0 {
                _marker: PhantomData,
            },
            HTM1: HTM1 {
                _marker: PhantomData,
            },
            RTOS: RTOS {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            WEEK: WEEK {
                _marker: PhantomData,
            },
            TACH0: TACH0 {
                _marker: PhantomData,
            },
            TACH1: TACH1 {
                _marker: PhantomData,
            },
            PWM0: PWM0 {
                _marker: PhantomData,
            },
            PWM1: PWM1 {
                _marker: PhantomData,
            },
            PWM2: PWM2 {
                _marker: PhantomData,
            },
            PWM3: PWM3 {
                _marker: PhantomData,
            },
            PWM4: PWM4 {
                _marker: PhantomData,
            },
            PWM5: PWM5 {
                _marker: PhantomData,
            },
            PWM10: PWM10 {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            FAN0: FAN0 {
                _marker: PhantomData,
            },
            FAN1: FAN1 {
                _marker: PhantomData,
            },
            LED0: LED0 {
                _marker: PhantomData,
            },
            LED1: LED1 {
                _marker: PhantomData,
            },
            RC_ID0: RC_ID0 {
                _marker: PhantomData,
            },
            RC_ID1: RC_ID1 {
                _marker: PhantomData,
            },
            KMS: KMS {
                _marker: PhantomData,
            },
            SMB0: SMB0 {
                _marker: PhantomData,
            },
            SMB1: SMB1 {
                _marker: PhantomData,
            },
            SMB2: SMB2 {
                _marker: PhantomData,
            },
            SMB3: SMB3 {
                _marker: PhantomData,
            },
            GP_SPI0: GP_SPI0 {
                _marker: PhantomData,
            },
            QMSPI: QMSPI {
                _marker: PhantomData,
            },
            TFDP: TFDP {
                _marker: PhantomData,
            },
            VCI: VCI {
                _marker: PhantomData,
            },
            VBAT_RAM: VBAT_RAM {
                _marker: PhantomData,
            },
            VBAT: VBAT {
                _marker: PhantomData,
            },
            EC_REG_BANK: EC_REG_BANK {
                _marker: PhantomData,
            },
            EFUSE: EFUSE {
                _marker: PhantomData,
            },
            SYS_TICK: SYS_TICK {
                _marker: PhantomData,
            },
            SYSTEM_CONTROL: SYSTEM_CONTROL {
                _marker: PhantomData,
            },
        }
    }
}
