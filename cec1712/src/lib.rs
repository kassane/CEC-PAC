#![doc = "Peripheral access API for CEC1712H_B2_SX microcontrollers (generated using svd2rust v0.25.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.25.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn GIRQ08();
    fn GIRQ09();
    fn GIRQ10();
    fn GIRQ11();
    fn GIRQ12();
    fn GIRQ13();
    fn GIRQ14();
    fn GIRQ15();
    fn GIRQ18();
    fn GIRQ20();
    fn GIRQ21();
    fn GIRQ23();
    fn GIRQ26();
    fn I2CSMB0();
    fn I2CSMB1();
    fn I2CSMB2();
    fn I2CSMB3();
    fn DMA_CH00();
    fn DMA_CH01();
    fn DMA_CH02();
    fn DMA_CH03();
    fn DMA_CH04();
    fn DMA_CH05();
    fn DMA_CH06();
    fn DMA_CH07();
    fn DMA_CH08();
    fn DMA_CH09();
    fn DMA_CH10();
    fn DMA_CH11();
    fn UART0();
    fn UART1();
    fn UART2();
    fn TACH0();
    fn TACH1();
    fn ADC_SNGL();
    fn ADC_RPT();
    fn LED0();
    fn LED1();
    fn QMSPI();
    fn TMR();
    fn HTMR0();
    fn HTMR1();
    fn WK();
    fn WKSUB();
    fn WKSEC();
    fn WKSUBSEC();
    fn SYSPWR();
    fn RTC();
    fn RTC_ALARM();
    fn VCI_IN0();
    fn VCI_IN1();
    fn TIMER16_0();
    fn TIMER16_1();
    fn TIMER32_0();
    fn TIMER32_1();
    fn CCT();
    fn CCT_CAP0();
    fn CCT_CAP1();
    fn CCT_CAP2();
    fn CCT_CAP3();
    fn CCT_CAP4();
    fn CCT_CAP5();
    fn CCT_CMP0();
    fn CCT_CMP1();
    fn I2CSMB4();
    fn I2C0();
    fn I2C1();
    fn I2C2();
    fn WDT();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 172] = [
    Vector { _handler: GIRQ08 },
    Vector { _handler: GIRQ09 },
    Vector { _handler: GIRQ10 },
    Vector { _handler: GIRQ11 },
    Vector { _handler: GIRQ12 },
    Vector { _handler: GIRQ13 },
    Vector { _handler: GIRQ14 },
    Vector { _handler: GIRQ15 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ18 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ20 },
    Vector { _handler: GIRQ21 },
    Vector { _handler: GIRQ23 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ26 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2CSMB0 },
    Vector { _handler: I2CSMB1 },
    Vector { _handler: I2CSMB2 },
    Vector { _handler: I2CSMB3 },
    Vector { _handler: DMA_CH00 },
    Vector { _handler: DMA_CH01 },
    Vector { _handler: DMA_CH02 },
    Vector { _handler: DMA_CH03 },
    Vector { _handler: DMA_CH04 },
    Vector { _handler: DMA_CH05 },
    Vector { _handler: DMA_CH06 },
    Vector { _handler: DMA_CH07 },
    Vector { _handler: DMA_CH08 },
    Vector { _handler: DMA_CH09 },
    Vector { _handler: DMA_CH10 },
    Vector { _handler: DMA_CH11 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: UART2 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TACH0 },
    Vector { _handler: TACH1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: ADC_SNGL },
    Vector { _handler: ADC_RPT },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: LED0 },
    Vector { _handler: LED1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: QMSPI },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR },
    Vector { _handler: HTMR0 },
    Vector { _handler: HTMR1 },
    Vector { _handler: WK },
    Vector { _handler: WKSUB },
    Vector { _handler: WKSEC },
    Vector { _handler: WKSUBSEC },
    Vector { _handler: SYSPWR },
    Vector { _handler: RTC },
    Vector {
        _handler: RTC_ALARM,
    },
    Vector { _reserved: 0 },
    Vector { _handler: VCI_IN0 },
    Vector { _handler: VCI_IN1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: TIMER16_0,
    },
    Vector {
        _handler: TIMER16_1,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: TIMER32_0,
    },
    Vector {
        _handler: TIMER32_1,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CCT },
    Vector { _handler: CCT_CAP0 },
    Vector { _handler: CCT_CAP1 },
    Vector { _handler: CCT_CAP2 },
    Vector { _handler: CCT_CAP3 },
    Vector { _handler: CCT_CAP4 },
    Vector { _handler: CCT_CAP5 },
    Vector { _handler: CCT_CMP0 },
    Vector { _handler: CCT_CMP1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2CSMB4 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2C0 },
    Vector { _handler: I2C1 },
    Vector { _handler: I2C2 },
    Vector { _handler: WDT },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "5 - GIRQ13"]
    GIRQ13 = 5,
    #[doc = "6 - GIRQ14"]
    GIRQ14 = 6,
    #[doc = "7 - GIRQ15"]
    GIRQ15 = 7,
    #[doc = "10 - GIRQ18"]
    GIRQ18 = 10,
    #[doc = "12 - GIRQ20"]
    GIRQ20 = 12,
    #[doc = "13 - GIRQ21"]
    GIRQ21 = 13,
    #[doc = "14 - GIRQ23"]
    GIRQ23 = 14,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - I2CSMB0"]
    I2CSMB0 = 20,
    #[doc = "21 - I2CSMB1"]
    I2CSMB1 = 21,
    #[doc = "22 - I2CSMB2"]
    I2CSMB2 = 22,
    #[doc = "23 - I2CSMB3"]
    I2CSMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "34 - DMA_CH10"]
    DMA_CH10 = 34,
    #[doc = "35 - DMA_CH11"]
    DMA_CH11 = 35,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "41 - UART1"]
    UART1 = 41,
    #[doc = "44 - UART2"]
    UART2 = 44,
    #[doc = "71 - TACH0"]
    TACH0 = 71,
    #[doc = "72 - TACH1"]
    TACH1 = 72,
    #[doc = "78 - ADC_SNGL"]
    ADC_SNGL = 78,
    #[doc = "79 - ADC_RPT"]
    ADC_RPT = 79,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "91 - QMSPI"]
    QMSPI = 91,
    #[doc = "111 - TMR"]
    TMR = 111,
    #[doc = "112 - HTMR0"]
    HTMR0 = 112,
    #[doc = "113 - HTMR1"]
    HTMR1 = 113,
    #[doc = "114 - WK"]
    WK = 114,
    #[doc = "115 - WKSUB"]
    WKSUB = 115,
    #[doc = "116 - WKSEC"]
    WKSEC = 116,
    #[doc = "117 - WKSUBSEC"]
    WKSUBSEC = 117,
    #[doc = "118 - SYSPWR"]
    SYSPWR = 118,
    #[doc = "119 - RTC"]
    RTC = 119,
    #[doc = "120 - RTC_ALARM"]
    RTC_ALARM = 120,
    #[doc = "122 - VCI_IN0"]
    VCI_IN0 = 122,
    #[doc = "123 - VCI_IN1"]
    VCI_IN1 = 123,
    #[doc = "136 - TIMER16_0"]
    TIMER16_0 = 136,
    #[doc = "137 - TIMER16_1"]
    TIMER16_1 = 137,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "146 - CCT"]
    CCT = 146,
    #[doc = "147 - CCT_CAP0"]
    CCT_CAP0 = 147,
    #[doc = "148 - CCT_CAP1"]
    CCT_CAP1 = 148,
    #[doc = "149 - CCT_CAP2"]
    CCT_CAP2 = 149,
    #[doc = "150 - CCT_CAP3"]
    CCT_CAP3 = 150,
    #[doc = "151 - CCT_CAP4"]
    CCT_CAP4 = 151,
    #[doc = "152 - CCT_CAP5"]
    CCT_CAP5 = 152,
    #[doc = "153 - CCT_CMP0"]
    CCT_CMP0 = 153,
    #[doc = "154 - CCT_CMP1"]
    CCT_CMP1 = 154,
    #[doc = "158 - I2CSMB4"]
    I2CSMB4 = 158,
    #[doc = "168 - I2C0"]
    I2C0 = 168,
    #[doc = "169 - I2C1"]
    I2C1 = 169,
    #[doc = "170 - I2C2"]
    I2C2 = 170,
    #[doc = "171 - WDT"]
    WDT = 171,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip"]
pub struct PCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PCR {}
impl PCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcr::RegisterBlock = 0x4008_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PCR {
    type Target = pcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PCR").finish()
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip"]
pub mod pcr;
#[doc = "DMA Main Registers"]
pub struct DMA_MAIN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_MAIN {}
impl DMA_MAIN {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_main::RegisterBlock = 0x4000_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_main::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_MAIN {
    type Target = dma_main::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_MAIN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_MAIN").finish()
    }
}
#[doc = "DMA Main Registers"]
pub mod dma_main;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN00 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN00 {}
impl DMA_CHAN00 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan00::RegisterBlock = 0x4000_2440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan00::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN00 {
    type Target = dma_chan00::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN00 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN00").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub mod dma_chan00;
#[doc = "DMA Channel 01 Registers"]
pub struct DMA_CHAN01 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN01 {}
impl DMA_CHAN01 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan01::RegisterBlock = 0x4000_2480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan01::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN01 {
    type Target = dma_chan01::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN01").finish()
    }
}
#[doc = "DMA Channel 01 Registers"]
pub mod dma_chan01;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN02 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN02 {}
impl DMA_CHAN02 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_24c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN02 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN02 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN02").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub mod dma_chan02;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN03 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN03 {}
impl DMA_CHAN03 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN03 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN03").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan03;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN04 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN04 {}
impl DMA_CHAN04 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN04 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN04 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN04").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan04;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN05 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN05 {}
impl DMA_CHAN05 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN05 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN05 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN05").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan05;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN06 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN06 {}
impl DMA_CHAN06 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_25c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN06 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN06 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN06").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan06;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN07 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN07 {}
impl DMA_CHAN07 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN07 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN07 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN07").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan07;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN08 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN08 {}
impl DMA_CHAN08 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN08 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN08 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN08").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan08;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN09 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN09 {}
impl DMA_CHAN09 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN09 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN09 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN09").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan09;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN10 {}
impl DMA_CHAN10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_26c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN10 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN10").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan10;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN11 {}
impl DMA_CHAN11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN11 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN11").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan11;
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub struct ECIA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ECIA {}
impl ECIA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecia::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecia::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ECIA {
    type Target = ecia::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ECIA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ECIA").finish()
    }
}
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub mod ecia;
#[doc = "The Logical Device Configuration registers support motherboard designs in\n which the resources required by their components are known and assigned by the BIOS\n at POST."]
pub struct GCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GCR {}
impl GCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gcr::RegisterBlock = 0x400f_ff00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GCR {
    type Target = gcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GCR").finish()
    }
}
#[doc = "The Logical Device Configuration registers support motherboard designs in\n which the resources required by their components are known and assigned by the BIOS\n at POST."]
pub mod gcr;
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x400f_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub mod uart0;
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x400f_2800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub use uart0 as uart1;
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x400f_2c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub use uart0 as uart2;
#[doc = "GPIO Pin Control Registers"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO Pin Control Registers"]
pub mod gpio;
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub mod wdt;
#[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub struct TIMER16_0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_0 {}
impl TIMER16_0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_0 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_0").finish()
    }
}
#[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub mod timer16_0;
#[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub struct TIMER16_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER16_1 {}
impl TIMER16_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer16_0::RegisterBlock = 0x4000_0c20 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer16_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER16_1 {
    type Target = timer16_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER16_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER16_1").finish()
    }
}
#[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub use timer16_0 as timer16_1;
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub struct TIMER32_0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_0 {}
impl TIMER32_0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_0 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_0").finish()
    }
}
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub mod timer32_0;
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub struct TIMER32_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_1 {}
impl TIMER32_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0ca0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_1 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_1").finish()
    }
}
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base"]
pub use timer32_0 as timer32_1;
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub struct CCT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CCT {}
impl CCT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cct::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cct::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CCT {
    type Target = cct::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CCT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CCT").finish()
    }
}
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub mod cct;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode"]
pub struct HTM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM0 {}
impl HTM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM0 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM0").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode"]
pub mod htm0;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode"]
pub struct HTM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM1 {}
impl HTM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM1 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM1").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode"]
pub use htm0 as htm1;
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub struct RTOS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTOS {}
impl RTOS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtos::RegisterBlock = 0x4000_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtos::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTOS {
    type Target = rtos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTOS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTOS").finish()
    }
}
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub mod rtos;
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled"]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x400f_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled"]
pub mod rtc;
#[doc = "The Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state"]
pub struct WEEK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WEEK {}
impl WEEK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const week::RegisterBlock = 0x4000_ac80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const week::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WEEK {
    type Target = week::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WEEK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WEEK").finish()
    }
}
#[doc = "The Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state"]
pub mod week;
#[doc = "This block monitors TACH output signals from various types of fans, and determines their speed."]
pub struct TACH0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TACH0 {}
impl TACH0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tach0::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tach0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TACH0 {
    type Target = tach0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TACH0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TACH0").finish()
    }
}
#[doc = "This block monitors TACH output signals from various types of fans, and determines their speed."]
pub mod tach0;
#[doc = "This block monitors TACH output signals from various types of fans, and determines their speed."]
pub struct TACH1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TACH1 {}
impl TACH1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tach0::RegisterBlock = 0x4000_6010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tach0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TACH1 {
    type Target = tach0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TACH1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TACH1").finish()
    }
}
#[doc = "This block monitors TACH output signals from various types of fans, and determines their speed."]
pub use tach0 as tach1;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM0 {}
impl PWM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM0").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub mod pwm0;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM2 {}
impl PWM2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM2 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM2").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub use pwm0 as pwm2;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM3 {}
impl PWM3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5830 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM3 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM3").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub use pwm0 as pwm3;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM5 {}
impl PWM5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5850 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM5 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM5").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub use pwm0 as pwm5;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM6 {}
impl PWM6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5860 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM6 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM6").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub use pwm0 as pwm6;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub struct PWM7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM7 {}
impl PWM7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5870 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM7 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM7").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz"]
pub use pwm0 as pwm7;
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4000_7c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub mod adc;
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub struct LED0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED0 {}
impl LED0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED0 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED0").finish()
    }
}
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub mod led0;
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub struct LED1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED1 {}
impl LED1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED1 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED1").finish()
    }
}
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub use led0 as led1;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB0 {}
impl SMB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB0 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB0").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub mod smb0;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB1 {}
impl SMB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB1 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB1").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb1;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB2 {}
impl SMB2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB2 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB2").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb2;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB3 {}
impl SMB3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB3 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB3").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb3;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB4 {}
impl SMB4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB4 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB4").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb4;
#[doc = "The I2C interface can handle standard I2C interface."]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4000_5100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C0").finish()
    }
}
#[doc = "The I2C interface can handle standard I2C interface."]
pub mod i2c0;
#[doc = "The I2C interface can handle standard I2C interface."]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4000_5200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C1 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
#[doc = "The I2C interface can handle standard I2C interface."]
pub use i2c0 as i2c1;
#[doc = "The I2C interface can handle standard I2C interface."]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4000_5300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C2 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C2").finish()
    }
}
#[doc = "The I2C interface can handle standard I2C interface."]
pub use i2c0 as i2c2;
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface"]
pub struct QMSPI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QMSPI {}
impl QMSPI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qmspi::RegisterBlock = 0x4007_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qmspi::RegisterBlock {
        Self::PTR
    }
}
impl Deref for QMSPI {
    type Target = qmspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QMSPI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QMSPI").finish()
    }
}
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface"]
pub mod qmspi;
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub struct TFDP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TFDP {}
impl TFDP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tfdp::RegisterBlock = 0x4000_8c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tfdp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TFDP {
    type Target = tfdp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TFDP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TFDP").finish()
    }
}
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub mod tfdp;
#[doc = "The VBAT-Powered Control Interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub struct VCI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VCI {}
impl VCI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vci::RegisterBlock = 0x4000_ae00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vci::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VCI {
    type Target = vci::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VCI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VCI").finish()
    }
}
#[doc = "The VBAT-Powered Control Interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub mod vci;
#[doc = "The VBAT RAM is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub struct VBAT_RAM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VBAT_RAM {}
impl VBAT_RAM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vbat_ram::RegisterBlock = 0x4000_a800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vbat_ram::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VBAT_RAM {
    type Target = vbat_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VBAT_RAM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VBAT_RAM").finish()
    }
}
#[doc = "The VBAT RAM is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub mod vbat_ram;
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers"]
pub struct VBAT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VBAT {}
impl VBAT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vbat::RegisterBlock = 0x4000_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vbat::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VBAT {
    type Target = vbat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VBAT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VBAT").finish()
    }
}
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers"]
pub mod vbat;
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub struct EC_REG_BANK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EC_REG_BANK {}
impl EC_REG_BANK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ec_reg_bank::RegisterBlock = 0x4000_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ec_reg_bank::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EC_REG_BANK {
    type Target = ec_reg_bank::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EC_REG_BANK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EC_REG_BANK").finish()
    }
}
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub mod ec_reg_bank;
#[doc = "System timer"]
pub struct SYS_TICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS_TICK {}
impl SYS_TICK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sys_tick::RegisterBlock = 0xe000_e010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sys_tick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS_TICK {
    type Target = sys_tick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS_TICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS_TICK").finish()
    }
}
#[doc = "System timer"]
pub mod sys_tick;
#[doc = "System Control Registers"]
pub struct SYSTEM_CONTROL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTEM_CONTROL {}
impl SYSTEM_CONTROL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const system_control::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const system_control::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTEM_CONTROL {
    type Target = system_control::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTEM_CONTROL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTEM_CONTROL").finish()
    }
}
#[doc = "System Control Registers"]
pub mod system_control;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PCR"]
    pub PCR: PCR,
    #[doc = "DMA_MAIN"]
    pub DMA_MAIN: DMA_MAIN,
    #[doc = "DMA_CHAN00"]
    pub DMA_CHAN00: DMA_CHAN00,
    #[doc = "DMA_CHAN01"]
    pub DMA_CHAN01: DMA_CHAN01,
    #[doc = "DMA_CHAN02"]
    pub DMA_CHAN02: DMA_CHAN02,
    #[doc = "DMA_CHAN03"]
    pub DMA_CHAN03: DMA_CHAN03,
    #[doc = "DMA_CHAN04"]
    pub DMA_CHAN04: DMA_CHAN04,
    #[doc = "DMA_CHAN05"]
    pub DMA_CHAN05: DMA_CHAN05,
    #[doc = "DMA_CHAN06"]
    pub DMA_CHAN06: DMA_CHAN06,
    #[doc = "DMA_CHAN07"]
    pub DMA_CHAN07: DMA_CHAN07,
    #[doc = "DMA_CHAN08"]
    pub DMA_CHAN08: DMA_CHAN08,
    #[doc = "DMA_CHAN09"]
    pub DMA_CHAN09: DMA_CHAN09,
    #[doc = "DMA_CHAN10"]
    pub DMA_CHAN10: DMA_CHAN10,
    #[doc = "DMA_CHAN11"]
    pub DMA_CHAN11: DMA_CHAN11,
    #[doc = "ECIA"]
    pub ECIA: ECIA,
    #[doc = "GCR"]
    pub GCR: GCR,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "TIMER16_0"]
    pub TIMER16_0: TIMER16_0,
    #[doc = "TIMER16_1"]
    pub TIMER16_1: TIMER16_1,
    #[doc = "TIMER32_0"]
    pub TIMER32_0: TIMER32_0,
    #[doc = "TIMER32_1"]
    pub TIMER32_1: TIMER32_1,
    #[doc = "CCT"]
    pub CCT: CCT,
    #[doc = "HTM0"]
    pub HTM0: HTM0,
    #[doc = "HTM1"]
    pub HTM1: HTM1,
    #[doc = "RTOS"]
    pub RTOS: RTOS,
    #[doc = "RTC"]
    pub RTC: RTC,
    #[doc = "WEEK"]
    pub WEEK: WEEK,
    #[doc = "TACH0"]
    pub TACH0: TACH0,
    #[doc = "TACH1"]
    pub TACH1: TACH1,
    #[doc = "PWM0"]
    pub PWM0: PWM0,
    #[doc = "PWM2"]
    pub PWM2: PWM2,
    #[doc = "PWM3"]
    pub PWM3: PWM3,
    #[doc = "PWM5"]
    pub PWM5: PWM5,
    #[doc = "PWM6"]
    pub PWM6: PWM6,
    #[doc = "PWM7"]
    pub PWM7: PWM7,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "LED0"]
    pub LED0: LED0,
    #[doc = "LED1"]
    pub LED1: LED1,
    #[doc = "SMB0"]
    pub SMB0: SMB0,
    #[doc = "SMB1"]
    pub SMB1: SMB1,
    #[doc = "SMB2"]
    pub SMB2: SMB2,
    #[doc = "SMB3"]
    pub SMB3: SMB3,
    #[doc = "SMB4"]
    pub SMB4: SMB4,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "QMSPI"]
    pub QMSPI: QMSPI,
    #[doc = "TFDP"]
    pub TFDP: TFDP,
    #[doc = "VCI"]
    pub VCI: VCI,
    #[doc = "VBAT_RAM"]
    pub VBAT_RAM: VBAT_RAM,
    #[doc = "VBAT"]
    pub VBAT: VBAT,
    #[doc = "EC_REG_BANK"]
    pub EC_REG_BANK: EC_REG_BANK,
    #[doc = "SYS_TICK"]
    pub SYS_TICK: SYS_TICK,
    #[doc = "SYSTEM_CONTROL"]
    pub SYSTEM_CONTROL: SYSTEM_CONTROL,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PCR: PCR {
                _marker: PhantomData,
            },
            DMA_MAIN: DMA_MAIN {
                _marker: PhantomData,
            },
            DMA_CHAN00: DMA_CHAN00 {
                _marker: PhantomData,
            },
            DMA_CHAN01: DMA_CHAN01 {
                _marker: PhantomData,
            },
            DMA_CHAN02: DMA_CHAN02 {
                _marker: PhantomData,
            },
            DMA_CHAN03: DMA_CHAN03 {
                _marker: PhantomData,
            },
            DMA_CHAN04: DMA_CHAN04 {
                _marker: PhantomData,
            },
            DMA_CHAN05: DMA_CHAN05 {
                _marker: PhantomData,
            },
            DMA_CHAN06: DMA_CHAN06 {
                _marker: PhantomData,
            },
            DMA_CHAN07: DMA_CHAN07 {
                _marker: PhantomData,
            },
            DMA_CHAN08: DMA_CHAN08 {
                _marker: PhantomData,
            },
            DMA_CHAN09: DMA_CHAN09 {
                _marker: PhantomData,
            },
            DMA_CHAN10: DMA_CHAN10 {
                _marker: PhantomData,
            },
            DMA_CHAN11: DMA_CHAN11 {
                _marker: PhantomData,
            },
            ECIA: ECIA {
                _marker: PhantomData,
            },
            GCR: GCR {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            WDT: WDT {
                _marker: PhantomData,
            },
            TIMER16_0: TIMER16_0 {
                _marker: PhantomData,
            },
            TIMER16_1: TIMER16_1 {
                _marker: PhantomData,
            },
            TIMER32_0: TIMER32_0 {
                _marker: PhantomData,
            },
            TIMER32_1: TIMER32_1 {
                _marker: PhantomData,
            },
            CCT: CCT {
                _marker: PhantomData,
            },
            HTM0: HTM0 {
                _marker: PhantomData,
            },
            HTM1: HTM1 {
                _marker: PhantomData,
            },
            RTOS: RTOS {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            WEEK: WEEK {
                _marker: PhantomData,
            },
            TACH0: TACH0 {
                _marker: PhantomData,
            },
            TACH1: TACH1 {
                _marker: PhantomData,
            },
            PWM0: PWM0 {
                _marker: PhantomData,
            },
            PWM2: PWM2 {
                _marker: PhantomData,
            },
            PWM3: PWM3 {
                _marker: PhantomData,
            },
            PWM5: PWM5 {
                _marker: PhantomData,
            },
            PWM6: PWM6 {
                _marker: PhantomData,
            },
            PWM7: PWM7 {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            LED0: LED0 {
                _marker: PhantomData,
            },
            LED1: LED1 {
                _marker: PhantomData,
            },
            SMB0: SMB0 {
                _marker: PhantomData,
            },
            SMB1: SMB1 {
                _marker: PhantomData,
            },
            SMB2: SMB2 {
                _marker: PhantomData,
            },
            SMB3: SMB3 {
                _marker: PhantomData,
            },
            SMB4: SMB4 {
                _marker: PhantomData,
            },
            I2C0: I2C0 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            QMSPI: QMSPI {
                _marker: PhantomData,
            },
            TFDP: TFDP {
                _marker: PhantomData,
            },
            VCI: VCI {
                _marker: PhantomData,
            },
            VBAT_RAM: VBAT_RAM {
                _marker: PhantomData,
            },
            VBAT: VBAT {
                _marker: PhantomData,
            },
            EC_REG_BANK: EC_REG_BANK {
                _marker: PhantomData,
            },
            SYS_TICK: SYS_TICK {
                _marker: PhantomData,
            },
            SYSTEM_CONTROL: SYSTEM_CONTROL {
                _marker: PhantomData,
            },
        }
    }
}
