#![doc = "Peripheral access API for CEC1734_S0_2HW microcontrollers (generated using svd2rust v0.25.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.25.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn GIRQ08();
    fn GIRQ09();
    fn GIRQ10();
    fn GIRQ11();
    fn GIRQ12();
    fn GIRQ13();
    fn GIRQ14();
    fn GIRQ15();
    fn GIRQ16();
    fn GIRQ17();
    fn GIRQ18();
    fn GIRQ20();
    fn GIRQ21();
    fn GIRQ23();
    fn GIRQ24();
    fn GIRQ26();
    fn I2CSMB0();
    fn I2CSMB1();
    fn I2CSMB2();
    fn I2CSMB3();
    fn DMA_CH00();
    fn DMA_CH01();
    fn DMA_CH02();
    fn DMA_CH03();
    fn DMA_CH04();
    fn DMA_CH05();
    fn DMA_CH06();
    fn DMA_CH07();
    fn DMA_CH08();
    fn DMA_CH09();
    fn UART0();
    fn LED0();
    fn LED1();
    fn SPT0();
    fn QMSPI0();
    fn RTMR();
    fn HTMR0();
    fn HTMR1();
    fn EMC();
    fn TIMER32_0();
    fn TIMER32_1();
    fn CCT();
    fn CCT_CAP0();
    fn CCT_CAP1();
    fn CCT_CAP2();
    fn CCT_CAP3();
    fn CCT_CAP4();
    fn CCT_CAP5();
    fn CCT_CMP0();
    fn CCT_CMP1();
    fn I2CSMB4();
    fn WDT();
    fn CLK_MON();
    fn SWI0();
    fn SWI1();
    fn SWI2();
    fn SWI3();
    fn IMSPI();
    fn SPT1();
    fn SPIMON0_VLTN();
    fn SPIMON0_MTMON();
    fn SPIMON0_LTMON();
    fn SPIMON1_VLTN();
    fn SPIMON1_MTMON();
    fn SPIMON1_LTMON();
    fn VTR1_PAD_MON();
    fn VTR2_PAD_MON();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 196] = [
    Vector { _handler: GIRQ08 },
    Vector { _handler: GIRQ09 },
    Vector { _handler: GIRQ10 },
    Vector { _handler: GIRQ11 },
    Vector { _handler: GIRQ12 },
    Vector { _handler: GIRQ13 },
    Vector { _handler: GIRQ14 },
    Vector { _handler: GIRQ15 },
    Vector { _handler: GIRQ16 },
    Vector { _handler: GIRQ17 },
    Vector { _handler: GIRQ18 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ20 },
    Vector { _handler: GIRQ21 },
    Vector { _handler: GIRQ23 },
    Vector { _handler: GIRQ24 },
    Vector { _reserved: 0 },
    Vector { _handler: GIRQ26 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2CSMB0 },
    Vector { _handler: I2CSMB1 },
    Vector { _handler: I2CSMB2 },
    Vector { _handler: I2CSMB3 },
    Vector { _handler: DMA_CH00 },
    Vector { _handler: DMA_CH01 },
    Vector { _handler: DMA_CH02 },
    Vector { _handler: DMA_CH03 },
    Vector { _handler: DMA_CH04 },
    Vector { _handler: DMA_CH05 },
    Vector { _handler: DMA_CH06 },
    Vector { _handler: DMA_CH07 },
    Vector { _handler: DMA_CH08 },
    Vector { _handler: DMA_CH09 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: UART0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: LED0 },
    Vector { _handler: LED1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SPT0 },
    Vector { _handler: QMSPI0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: RTMR },
    Vector { _handler: HTMR0 },
    Vector { _handler: HTMR1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EMC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: TIMER32_0,
    },
    Vector {
        _handler: TIMER32_1,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CCT },
    Vector { _handler: CCT_CAP0 },
    Vector { _handler: CCT_CAP1 },
    Vector { _handler: CCT_CAP2 },
    Vector { _handler: CCT_CAP3 },
    Vector { _handler: CCT_CAP4 },
    Vector { _handler: CCT_CAP5 },
    Vector { _handler: CCT_CMP0 },
    Vector { _handler: CCT_CMP1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2CSMB4 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WDT },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CLK_MON },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SWI0 },
    Vector { _handler: SWI1 },
    Vector { _handler: SWI2 },
    Vector { _handler: SWI3 },
    Vector { _handler: IMSPI },
    Vector { _reserved: 0 },
    Vector { _handler: SPT1 },
    Vector {
        _handler: SPIMON0_VLTN,
    },
    Vector {
        _handler: SPIMON0_MTMON,
    },
    Vector {
        _handler: SPIMON0_LTMON,
    },
    Vector {
        _handler: SPIMON1_VLTN,
    },
    Vector {
        _handler: SPIMON1_MTMON,
    },
    Vector {
        _handler: SPIMON1_LTMON,
    },
    Vector {
        _handler: VTR1_PAD_MON,
    },
    Vector {
        _handler: VTR2_PAD_MON,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "5 - GIRQ13"]
    GIRQ13 = 5,
    #[doc = "6 - GIRQ14"]
    GIRQ14 = 6,
    #[doc = "7 - GIRQ15"]
    GIRQ15 = 7,
    #[doc = "8 - GIRQ16"]
    GIRQ16 = 8,
    #[doc = "9 - GIRQ17"]
    GIRQ17 = 9,
    #[doc = "10 - GIRQ18"]
    GIRQ18 = 10,
    #[doc = "12 - GIRQ20"]
    GIRQ20 = 12,
    #[doc = "13 - GIRQ21"]
    GIRQ21 = 13,
    #[doc = "14 - GIRQ23"]
    GIRQ23 = 14,
    #[doc = "15 - GIRQ24"]
    GIRQ24 = 15,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - I2CSMB0"]
    I2CSMB0 = 20,
    #[doc = "21 - I2CSMB1"]
    I2CSMB1 = 21,
    #[doc = "22 - I2CSMB2"]
    I2CSMB2 = 22,
    #[doc = "23 - I2CSMB3"]
    I2CSMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "90 - SPT0"]
    SPT0 = 90,
    #[doc = "91 - QMSPI0"]
    QMSPI0 = 91,
    #[doc = "111 - RTMR"]
    RTMR = 111,
    #[doc = "112 - HTMR0"]
    HTMR0 = 112,
    #[doc = "113 - HTMR1"]
    HTMR1 = 113,
    #[doc = "134 - EMC"]
    EMC = 134,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "146 - CCT"]
    CCT = 146,
    #[doc = "147 - CCT_CAP0"]
    CCT_CAP0 = 147,
    #[doc = "148 - CCT_CAP1"]
    CCT_CAP1 = 148,
    #[doc = "149 - CCT_CAP2"]
    CCT_CAP2 = 149,
    #[doc = "150 - CCT_CAP3"]
    CCT_CAP3 = 150,
    #[doc = "151 - CCT_CAP4"]
    CCT_CAP4 = 151,
    #[doc = "152 - CCT_CAP5"]
    CCT_CAP5 = 152,
    #[doc = "153 - CCT_CMP0"]
    CCT_CMP0 = 153,
    #[doc = "154 - CCT_CMP1"]
    CCT_CMP1 = 154,
    #[doc = "158 - I2CSMB4"]
    I2CSMB4 = 158,
    #[doc = "171 - WDT"]
    WDT = 171,
    #[doc = "174 - CLK_MON"]
    CLK_MON = 174,
    #[doc = "181 - SWI0"]
    SWI0 = 181,
    #[doc = "182 - SWI1"]
    SWI1 = 182,
    #[doc = "183 - SWI2"]
    SWI2 = 183,
    #[doc = "184 - SWI3"]
    SWI3 = 184,
    #[doc = "185 - IMSPI"]
    IMSPI = 185,
    #[doc = "187 - SPT1"]
    SPT1 = 187,
    #[doc = "188 - SPIMON0_VLTN"]
    SPIMON0_VLTN = 188,
    #[doc = "189 - SPIMON0_MTMON"]
    SPIMON0_MTMON = 189,
    #[doc = "190 - SPIMON0_LTMON"]
    SPIMON0_LTMON = 190,
    #[doc = "191 - SPIMON1_VLTN"]
    SPIMON1_VLTN = 191,
    #[doc = "192 - SPIMON1_MTMON"]
    SPIMON1_MTMON = 192,
    #[doc = "193 - SPIMON1_LTMON"]
    SPIMON1_LTMON = 193,
    #[doc = "194 - VTR1_PAD_MON"]
    VTR1_PAD_MON = 194,
    #[doc = "195 - VTR2_PAD_MON"]
    VTR2_PAD_MON = 195,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
pub struct PCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PCR {}
impl PCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcr::RegisterBlock = 0x4008_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PCR {
    type Target = pcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PCR").finish()
    }
}
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
pub mod pcr;
#[doc = "DMA Main Registers"]
pub struct DMA_MAIN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_MAIN {}
impl DMA_MAIN {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_main::RegisterBlock = 0x4000_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_main::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_MAIN {
    type Target = dma_main::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_MAIN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_MAIN").finish()
    }
}
#[doc = "DMA Main Registers"]
pub mod dma_main;
#[doc = "DMA Channel 00 Registers"]
pub struct DMA_CHAN00 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN00 {}
impl DMA_CHAN00 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan00::RegisterBlock = 0x4000_2440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan00::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN00 {
    type Target = dma_chan00::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN00 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN00").finish()
    }
}
#[doc = "DMA Channel 00 Registers"]
pub mod dma_chan00;
#[doc = "DMA Channel 01 Registers"]
pub struct DMA_CHAN01 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN01 {}
impl DMA_CHAN01 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan01::RegisterBlock = 0x4000_2480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan01::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN01 {
    type Target = dma_chan01::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN01").finish()
    }
}
#[doc = "DMA Channel 01 Registers"]
pub mod dma_chan01;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN02 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN02 {}
impl DMA_CHAN02 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_24c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN02 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN02 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN02").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub mod dma_chan02;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN03 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN03 {}
impl DMA_CHAN03 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN03 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN03").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan03;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN04 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN04 {}
impl DMA_CHAN04 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2540 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN04 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN04 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN04").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan04;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN05 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN05 {}
impl DMA_CHAN05 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2580 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN05 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN05 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN05").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan05;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN06 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN06 {}
impl DMA_CHAN06 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_25c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN06 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN06 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN06").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan06;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN07 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN07 {}
impl DMA_CHAN07 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN07 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN07 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN07").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan07;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN08 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN08 {}
impl DMA_CHAN08 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN08 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN08 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN08").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan08;
#[doc = "DMA Channel 02 Registers"]
pub struct DMA_CHAN09 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA_CHAN09 {}
impl DMA_CHAN09 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma_chan02::RegisterBlock = 0x4000_2680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma_chan02::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA_CHAN09 {
    type Target = dma_chan02::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA_CHAN09 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA_CHAN09").finish()
    }
}
#[doc = "DMA Channel 02 Registers"]
pub use dma_chan02 as dma_chan09;
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub struct ECIA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ECIA {}
impl ECIA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecia::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecia::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ECIA {
    type Target = ecia::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ECIA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ECIA").finish()
    }
}
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub mod ecia;
#[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
pub struct GCR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GCR {}
impl GCR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gcr::RegisterBlock = 0x400f_ff00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gcr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GCR {
    type Target = gcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GCR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GCR").finish()
    }
}
#[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
pub mod gcr;
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4000_c400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub mod uart0;
#[doc = "GPIO Pin Control Registers"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO Pin Control Registers"]
pub mod gpio;
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub mod wdt;
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub struct TIMER32_0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_0 {}
impl TIMER32_0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_0 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_0").finish()
    }
}
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub mod timer32_0;
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub struct TIMER32_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER32_1 {}
impl TIMER32_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer32_0::RegisterBlock = 0x4000_0ca0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer32_0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIMER32_1 {
    type Target = timer32_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIMER32_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIMER32_1").finish()
    }
}
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub use timer32_0 as timer32_1;
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub struct CCT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CCT {}
impl CCT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cct::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cct::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CCT {
    type Target = cct::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CCT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CCT").finish()
    }
}
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub mod cct;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub struct HTM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM0 {}
impl HTM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM0 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM0").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub mod htm0;
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub struct HTM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HTM1 {}
impl HTM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const htm0::RegisterBlock = 0x4000_9820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const htm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HTM1 {
    type Target = htm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HTM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HTM1").finish()
    }
}
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub use htm0 as htm1;
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub struct RTOS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTOS {}
impl RTOS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtos::RegisterBlock = 0x4000_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtos::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTOS {
    type Target = rtos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTOS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTOS").finish()
    }
}
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub mod rtos;
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
pub struct PWM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM0 {}
impl PWM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4000_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM0").finish()
    }
}
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
pub mod pwm0;
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub struct LED0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED0 {}
impl LED0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED0 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED0").finish()
    }
}
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub mod led0;
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub struct LED1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LED1 {}
impl LED1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0x4000_b900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LED1 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LED1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LED1").finish()
    }
}
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub use led0 as led1;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB0 {}
impl SMB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB0 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB0").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub mod smb0;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB1 {}
impl SMB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB1 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB1").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb1;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB2 {}
impl SMB2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB2 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB2").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb2;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB3 {}
impl SMB3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB3 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB3").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb3;
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub struct SMB4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMB4 {}
impl SMB4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMB4 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMB4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMB4").finish()
    }
}
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub use smb0 as smb4;
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
pub struct QMSPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QMSPI0 {}
impl QMSPI0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qmspi0::RegisterBlock = 0x4007_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qmspi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for QMSPI0 {
    type Target = qmspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QMSPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QMSPI0").finish()
    }
}
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
pub mod qmspi0;
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub struct TFDP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TFDP {}
impl TFDP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tfdp::RegisterBlock = 0x4000_8c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tfdp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TFDP {
    type Target = tfdp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TFDP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TFDP").finish()
    }
}
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub mod tfdp;
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
pub struct VTR_REG_BANK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VTR_REG_BANK {}
impl VTR_REG_BANK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vtr_reg_bank::RegisterBlock = 0x4000_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vtr_reg_bank::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VTR_REG_BANK {
    type Target = vtr_reg_bank::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VTR_REG_BANK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VTR_REG_BANK").finish()
    }
}
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
pub mod vtr_reg_bank;
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub struct EC_REG_BANK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EC_REG_BANK {}
impl EC_REG_BANK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ec_reg_bank::RegisterBlock = 0x4000_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ec_reg_bank::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EC_REG_BANK {
    type Target = ec_reg_bank::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EC_REG_BANK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EC_REG_BANK").finish()
    }
}
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub mod ec_reg_bank;
#[doc = "OTP Programming registers."]
pub struct OTP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for OTP {}
impl OTP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const otp::RegisterBlock = 0x4008_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const otp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for OTP {
    type Target = otp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for OTP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OTP").finish()
    }
}
#[doc = "OTP Programming registers."]
pub mod otp;
#[doc = "SPI Peripheral Target Register."]
pub struct SPT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPT0 {}
impl SPT0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spt0::RegisterBlock = 0x4000_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spt0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPT0 {
    type Target = spt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPT0").finish()
    }
}
#[doc = "SPI Peripheral Target Register."]
pub mod spt0;
#[doc = "SPI Peripheral Target Register."]
pub struct SPT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPT1 {}
impl SPT1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spt0::RegisterBlock = 0x4000_6c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spt0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPT1 {
    type Target = spt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPT1").finish()
    }
}
#[doc = "SPI Peripheral Target Register."]
pub use spt0 as spt1;
#[doc = "Internal Master SPI."]
pub struct IMSPI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IMSPI {}
impl IMSPI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const imspi::RegisterBlock = 0x4022_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const imspi::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IMSPI {
    type Target = imspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IMSPI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IMSPI").finish()
    }
}
#[doc = "Internal Master SPI."]
pub mod imspi;
#[doc = "System timer"]
pub struct SYS_TICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS_TICK {}
impl SYS_TICK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sys_tick::RegisterBlock = 0xe000_e010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sys_tick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS_TICK {
    type Target = sys_tick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS_TICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS_TICK").finish()
    }
}
#[doc = "System timer"]
pub mod sys_tick;
#[doc = "System Control Registers"]
pub struct SYSTEM_CONTROL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTEM_CONTROL {}
impl SYSTEM_CONTROL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const system_control::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const system_control::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTEM_CONTROL {
    type Target = system_control::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTEM_CONTROL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTEM_CONTROL").finish()
    }
}
#[doc = "System Control Registers"]
pub mod system_control;
#[doc = "Environmental Monitor Block"]
pub struct ENV_MON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ENV_MON {}
impl ENV_MON {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const env_mon::RegisterBlock = 0x4020_0600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const env_mon::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ENV_MON {
    type Target = env_mon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ENV_MON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ENV_MON").finish()
    }
}
#[doc = "Environmental Monitor Block"]
pub mod env_mon;
#[doc = "SPI Monitor Block"]
pub struct SPI_MON0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI_MON0 {}
impl SPI_MON0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi_mon0::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi_mon0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI_MON0 {
    type Target = spi_mon0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI_MON0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI_MON0").finish()
    }
}
#[doc = "SPI Monitor Block"]
pub mod spi_mon0;
#[doc = "SPI Monitor Block"]
pub struct SPI_MON1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI_MON1 {}
impl SPI_MON1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi_mon0::RegisterBlock = 0x4001_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi_mon0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI_MON1 {
    type Target = spi_mon0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI_MON1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI_MON1").finish()
    }
}
#[doc = "SPI Monitor Block"]
pub use spi_mon0 as spi_mon1;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PCR"]
    pub PCR: PCR,
    #[doc = "DMA_MAIN"]
    pub DMA_MAIN: DMA_MAIN,
    #[doc = "DMA_CHAN00"]
    pub DMA_CHAN00: DMA_CHAN00,
    #[doc = "DMA_CHAN01"]
    pub DMA_CHAN01: DMA_CHAN01,
    #[doc = "DMA_CHAN02"]
    pub DMA_CHAN02: DMA_CHAN02,
    #[doc = "DMA_CHAN03"]
    pub DMA_CHAN03: DMA_CHAN03,
    #[doc = "DMA_CHAN04"]
    pub DMA_CHAN04: DMA_CHAN04,
    #[doc = "DMA_CHAN05"]
    pub DMA_CHAN05: DMA_CHAN05,
    #[doc = "DMA_CHAN06"]
    pub DMA_CHAN06: DMA_CHAN06,
    #[doc = "DMA_CHAN07"]
    pub DMA_CHAN07: DMA_CHAN07,
    #[doc = "DMA_CHAN08"]
    pub DMA_CHAN08: DMA_CHAN08,
    #[doc = "DMA_CHAN09"]
    pub DMA_CHAN09: DMA_CHAN09,
    #[doc = "ECIA"]
    pub ECIA: ECIA,
    #[doc = "GCR"]
    pub GCR: GCR,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "TIMER32_0"]
    pub TIMER32_0: TIMER32_0,
    #[doc = "TIMER32_1"]
    pub TIMER32_1: TIMER32_1,
    #[doc = "CCT"]
    pub CCT: CCT,
    #[doc = "HTM0"]
    pub HTM0: HTM0,
    #[doc = "HTM1"]
    pub HTM1: HTM1,
    #[doc = "RTOS"]
    pub RTOS: RTOS,
    #[doc = "PWM0"]
    pub PWM0: PWM0,
    #[doc = "LED0"]
    pub LED0: LED0,
    #[doc = "LED1"]
    pub LED1: LED1,
    #[doc = "SMB0"]
    pub SMB0: SMB0,
    #[doc = "SMB1"]
    pub SMB1: SMB1,
    #[doc = "SMB2"]
    pub SMB2: SMB2,
    #[doc = "SMB3"]
    pub SMB3: SMB3,
    #[doc = "SMB4"]
    pub SMB4: SMB4,
    #[doc = "QMSPI0"]
    pub QMSPI0: QMSPI0,
    #[doc = "TFDP"]
    pub TFDP: TFDP,
    #[doc = "VTR_REG_BANK"]
    pub VTR_REG_BANK: VTR_REG_BANK,
    #[doc = "EC_REG_BANK"]
    pub EC_REG_BANK: EC_REG_BANK,
    #[doc = "OTP"]
    pub OTP: OTP,
    #[doc = "SPT0"]
    pub SPT0: SPT0,
    #[doc = "SPT1"]
    pub SPT1: SPT1,
    #[doc = "IMSPI"]
    pub IMSPI: IMSPI,
    #[doc = "SYS_TICK"]
    pub SYS_TICK: SYS_TICK,
    #[doc = "SYSTEM_CONTROL"]
    pub SYSTEM_CONTROL: SYSTEM_CONTROL,
    #[doc = "ENV_MON"]
    pub ENV_MON: ENV_MON,
    #[doc = "SPI_MON0"]
    pub SPI_MON0: SPI_MON0,
    #[doc = "SPI_MON1"]
    pub SPI_MON1: SPI_MON1,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PCR: PCR {
                _marker: PhantomData,
            },
            DMA_MAIN: DMA_MAIN {
                _marker: PhantomData,
            },
            DMA_CHAN00: DMA_CHAN00 {
                _marker: PhantomData,
            },
            DMA_CHAN01: DMA_CHAN01 {
                _marker: PhantomData,
            },
            DMA_CHAN02: DMA_CHAN02 {
                _marker: PhantomData,
            },
            DMA_CHAN03: DMA_CHAN03 {
                _marker: PhantomData,
            },
            DMA_CHAN04: DMA_CHAN04 {
                _marker: PhantomData,
            },
            DMA_CHAN05: DMA_CHAN05 {
                _marker: PhantomData,
            },
            DMA_CHAN06: DMA_CHAN06 {
                _marker: PhantomData,
            },
            DMA_CHAN07: DMA_CHAN07 {
                _marker: PhantomData,
            },
            DMA_CHAN08: DMA_CHAN08 {
                _marker: PhantomData,
            },
            DMA_CHAN09: DMA_CHAN09 {
                _marker: PhantomData,
            },
            ECIA: ECIA {
                _marker: PhantomData,
            },
            GCR: GCR {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            WDT: WDT {
                _marker: PhantomData,
            },
            TIMER32_0: TIMER32_0 {
                _marker: PhantomData,
            },
            TIMER32_1: TIMER32_1 {
                _marker: PhantomData,
            },
            CCT: CCT {
                _marker: PhantomData,
            },
            HTM0: HTM0 {
                _marker: PhantomData,
            },
            HTM1: HTM1 {
                _marker: PhantomData,
            },
            RTOS: RTOS {
                _marker: PhantomData,
            },
            PWM0: PWM0 {
                _marker: PhantomData,
            },
            LED0: LED0 {
                _marker: PhantomData,
            },
            LED1: LED1 {
                _marker: PhantomData,
            },
            SMB0: SMB0 {
                _marker: PhantomData,
            },
            SMB1: SMB1 {
                _marker: PhantomData,
            },
            SMB2: SMB2 {
                _marker: PhantomData,
            },
            SMB3: SMB3 {
                _marker: PhantomData,
            },
            SMB4: SMB4 {
                _marker: PhantomData,
            },
            QMSPI0: QMSPI0 {
                _marker: PhantomData,
            },
            TFDP: TFDP {
                _marker: PhantomData,
            },
            VTR_REG_BANK: VTR_REG_BANK {
                _marker: PhantomData,
            },
            EC_REG_BANK: EC_REG_BANK {
                _marker: PhantomData,
            },
            OTP: OTP {
                _marker: PhantomData,
            },
            SPT0: SPT0 {
                _marker: PhantomData,
            },
            SPT1: SPT1 {
                _marker: PhantomData,
            },
            IMSPI: IMSPI {
                _marker: PhantomData,
            },
            SYS_TICK: SYS_TICK {
                _marker: PhantomData,
            },
            SYSTEM_CONTROL: SYSTEM_CONTROL {
                _marker: PhantomData,
            },
            ENV_MON: ENV_MON {
                _marker: PhantomData,
            },
            SPI_MON0: SPI_MON0 {
                _marker: PhantomData,
            },
            SPI_MON1: SPI_MON1 {
                _marker: PhantomData,
            },
        }
    }
}
